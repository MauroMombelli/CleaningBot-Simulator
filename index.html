<html>
    <head>
      <title>Box2D/WebGL Demo</title>
      <script src="CubicVR.min.js" type="text/javascript"></script>
      <script>
        var Module = { TOTAL_MEMORY: 256*1024*1024 };
      </script>
      <script src="box2d.js" type="text/javascript"></script>
      <style type="text/css">
        body { background-color: #ccc; }
      </style>

      <script type="text/javascript">
		var startUp, restart;
		(function() {
			function robot_direction(vel, angle){
				if (vel > 1){
					vel = 1;
				}
				
				if (vel < -1){
					vel = -1;
				}
				if ( angle != robot.GetAngle() ){
					robot.SetTransform(robot.GetPosition(), angle);
				}
				
				var move = new Box2D.b2Vec2(-Math.sin(robot.GetAngle()) * vel, Math.cos(robot.GetAngle()) * vel);
				robot.SetLinearVelocity(move);
				
				console.log("pos ["+robot.GetPosition().get_x() + ", "  +robot.GetPosition().get_y() + "] "+ robot.GetAngle());
			}
		
			var storage = {};
			// Box2D-interfacing code
			var gravity = new Box2D.b2Vec2(0.0, 0.0);
			var world = new Box2D.b2World(gravity);

			//build ground
			var bd_ground = new Box2D.b2BodyDef();
			var ground = world.CreateBody(bd_ground);
			var shape0 = new Box2D.b2EdgeShape();
			shape0.Set(new Box2D.b2Vec2(-40.0, -6.0), new Box2D.b2Vec2(40.0, -6.0));
			ground.CreateFixture(shape0, 0.0);

			//build robot shape
			var circleShape = new Box2D.b2CircleShape();
			circleShape.set_m_radius( 1 );
			//build robot physic body
			var robot_bg = new Box2D.b2BodyDef();
			robot_bg.set_type(Box2D.b2_dynamicBody);
			//create object in the world
			var robot = world.CreateBody(robot_bg);
			robot.CreateFixture( circleShape, 0.5 );
			robot.SetTransform(new Box2D.b2Vec2(0, 0), Math.PI+Math.PI/4);
			robot.SetAwake(1);
			robot.SetActive(1);
			robot.SetFixedRotation(true);
			
			// Main demo code
			var totalTime = 0;
			var boxes = [];
			var position = [0,0,0];
			function simulate(dt) {
			
				var codeAI = document.getElementById('robotAIloop');
				codeAI && eval(codeAI.value);
			
				world.Step(dt, 2, 2);
				
				// Read box2d data into JS objects
				
				robotRender.position[0] = robot.GetPosition().get_x();
				robotRender.position[1] = robot.GetPosition().get_y();
				
				//robotRender.position[2] = 0; //3d off
				robotRender.rotation = [0, 0, robot.GetAngle()*180/Math.PI];
				/*
				console.log("robot: "+robotRender.position[0]+" "+robotRender.position[1]);
				*/
				totalTime += dt;
			}
			var fpsInfo = {
				dts: 0,
				num: 0,
				lastHUD: Date.now(),
				allNum: 0,
				all: 0,
			};
			var outElement = null;
			function showFPS(dt) {
				if (!outElement) outElement = document.getElementById('out');
				var now = Date.now();
				fpsInfo.dts += dt;
				fpsInfo.num++;
				if (now - fpsInfo.lastHUD > 500) {
					var curr = 1/(fpsInfo.dts/fpsInfo.num);
					fpsInfo.allNum++;
					var alpha = Math.min(1, 2/fpsInfo.allNum);
					fpsInfo.all = alpha*curr + (1-alpha)*fpsInfo.all;
					outElement.value = Math.round(curr) + ' / ' + Math.round(fpsInfo.all);
					fpsInfo.lastHUD = now;
					fpsInfo.dts = 0;
					fpsInfo.num = 0;
				}
			}
			var FLOOR_SIZE = 100;
			var FLOOR_HEIGHT = -56
			// CubicVR code
			startUp = function() {
				var canvas = document.getElementById("canvas");
				canvas.width = screen.width*0.5;
				canvas.height = screen.height*0.55;
				var gl = CubicVR.GLCore.init(canvas);
				if (!gl) {
					alert("Sorry, no WebGL support :(");
					return;
				};
				var scene = new CubicVR.Scene(canvas.width, canvas.height, 70);
				var light = new CubicVR.Light({
					type:CubicVR.enums.light.type.POINT,
					position: [0, 0, 5],
					intensity: 0.9,
					areaCeiling: 80,
					areaFloor: FLOOR_HEIGHT,
					areaAxis: [15, 10],
					distance: 60,
					mapRes: 1024
				});
				scene.bindLight(light);
				scene.camera.position = [0, 2.4, 17];
				scene.camera.target = [0, 2.4, 0];
				
				
				var robotMaterial = new CubicVR.Material({
					textures: {
					color: new CubicVR.Texture("cube1.jpg")
					}
				});
				var robotMeshes = new CubicVR.primitives.box({
					size: 1.0,
					material: robotMaterial,
					uvmapper: {
						projectionMode: CubicVR.enums.uv.projection.CUBIC,
						scale: [1, 1, 1]
					}
				}).calcNormals().triangulateQuads().compile().clean();
				
				
				
				var floorMaterial = new CubicVR.Material({
					textures: {
					color: new CubicVR.Texture("cube3.jpg")
					}
				});
				var floorMesh = new  CubicVR.primitives.box({
					size: FLOOR_SIZE,
					material: floorMaterial,
					uvmapper: {
						projectionMode: CubicVR.enums.uv.projection.CUBIC,
						scale: [4, 4, 4]
					}
				}).calcNormals().triangulateQuads().compile().clean();
				
				
				var floor_ = new CubicVR.SceneObject({ mesh: floorMesh, position: [0, FLOOR_HEIGHT, 0] });
				scene.bindSceneObject(floor_, true);
				
				robotRender = new CubicVR.SceneObject({ mesh: robotMeshes, position: [0, 0, 0] });
				scene.bindSceneObject(robotRender, true);
				
				
				//var mvc = new CubicVR.MouseViewController(canvas, scene.camera);
				CubicVR.MainLoop(function(timer, gl) {
					var dt = timer.getLastUpdateSeconds();
					simulate(dt);
					scene.updateShadows();
					scene.render();
					showFPS(dt);
				});
			}
        })();
      </script>
    </head>
    <body onload="startUp()">
      <center>
        <h2>box2d.js WebGL Demo</h2>
        <canvas id="canvas" width="300" height="600" style="float:left;"></canvas>
        <br><br>
		<textarea id="robotAIloop" style="width:600px; height:600px;">
if (!storage['setup']){
	storage['setup'] = 1;
	storage['angle'] = 0;
	console.log("setup");
	var d = new Date();
	storage['lastUpdate'] = d.getTime();
}else{
	var d = new Date();
	var timestamp = d.getTime();
	if ( (timestamp - storage['lastUpdate']) > 1000){
		console.log("update");
		storage['lastUpdate'] = timestamp;
		storage['angle'] += Math.PI/2;
		robot_direction(1, storage['angle']);
	}
}
        </textarea>
        <div>FPS (current / stable): <input type="text" id="out" readonly="1" size="7"></div>
        <div id="info"></div>
        <p>
        This is <b><a href="https://github.com/kripken/box2d.js">box2d.js</a></b>, a port of
        the <b><a href="http://box2d.org/">Box2D physics engine</a></b> from C++ to JavaScript
        using <b><a href="http://emscripten.org">Emscripten</a></b>. WebGL rendering in this demo is done using
        <b><a href="https://github.com/cjcliffe/CubicVR.js/">CubicVR.js</a></b>.
        </p>
        <input type="button" onclick="restart()" value="restart">
      </center>
    </body>
</html>
